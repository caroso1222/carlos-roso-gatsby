{"componentChunkName":"component---src-templates-blog-post-js","path":"/ctti-draft/","result":{"data":{"markdownRemark":{"html":"<h1>Changelog</h1>\n<p>From May 12 moving forward, I’ll publish updates to Google Docs. This link will become outdated.</p>\n<p><strong>You’ll be able to view and make comments. <a href=\"https://docs.google.com/document/d/1lCw1QnUjDc-mKTfIMRcTWZPTFk9KRPMjeXlK4tHwXks/edit?usp=sharing\" target=\"_blank\" rel=\"nofollow\">See draft here.</a></strong></p>\n<ul>\n<li>\n<p><strong>v1.8 - May 12</strong>: Switched to GDocs</p>\n</li>\n<li>\n<p><strong>v1.7 - May 11</strong>: Add Interview tips for the “Test Project” chapter</p>\n</li>\n<li>\n<p><strong>v1.6 - May 10</strong>: Write Intro</p>\n</li>\n<li>\n<p><strong>v1.5 - May 8</strong>: Finish section “Test Project”</p>\n</li>\n<li>\n<p><strong>v1.4 - May 7</strong>: Add progress on section “Test Project”</p>\n</li>\n<li>\n<p><strong>v1.3 - May 6</strong>: Add resources on BigO complexity</p>\n</li>\n<li>\n<p><strong>v1.2 - May 4</strong>: Add new coding problem: “repeated string”</p>\n</li>\n<li>\n<p><strong>v1.1 - Apr 30</strong>: Add a new problem with its solution to the online coding assessment.</p>\n</li>\n<li>\n<p><strong>v1.0 - Apr 29</strong>: First draft with in-depth review on the <strong>English interview and the first online coding assessment</strong>.</p>\n</li>\n</ul>\n<div class=\"divider\"></div>\n<h1>Intro</h1>\n<h2>What’s Toptal?</h2>\n<p>For starters, Toptal is a remote work marketplace which claims to accept only 3% of the applicants. As such, the work quality and rates are much, much higher than other non-vetting platforms like Upwork, Freelancer, Freeeup, you name it. Toptal connects you with clients all over the world in engagements that can be full-time, part-time or hourly. Most of the jobs are likely to be long term. Once you get into the marketplace, you’ll probably find your first job in 3 or 4 weeks, given you put good time into polishing your profile.</p>\n<h2>Why Toptal?</h2>\n<p>I’ve gone through tough interviews in most of these top remote platforms. All of them claim to filter out the vast majority of applicants. However, even after taking jobs at some of these marketplaces, I can honestly say Toptal has been the best of them. The fact that you can set your own rate and your weekly availability makes it very flexible for a digital nomad like me. They filter out companies with a rigorous process too, so you’re almost guaranteed to work with awesome teams. The cash is top; you get much more than what yo</p>\n<h2>How to prepare</h2>\n<p>This guide contains practical tips to ace every step of the interview. First, I dive deep into the English test. This step of the process filters out ~76% of the applicants so it’s critical to make it through. Then I go into the most daunting phase: the coding interviews. I cover everything from what to expect to preparation tips. You’ll also be able to practice with a handful of exercises and understand the solutions right there. Finally, I talk about the Test Project, which is the last step of the screening. I’ll go through a dummy exercise for full stack web and develop a strategy to deliver a job-winning project in the frontend and backend.</p>\n<p>Remember Toptal is not the only option you have. Once you go through all the preparation, you’ll be ready to tackle similar interviews in several other top-remote marketplaces. Big tech companies (Facebook, Amazon, Google) will also ask you to be good at english speaking and algorithms. Please keep that in mind, you’re not preparing for just one interview, you’re investing hard on your future as a developer.</p>\n<h1>English Interview</h1>\n<p>This section will help you hone your speaking skills and prepare for the interview. It’s mostly directed for those who are already familiar with the language, who can understand and decently speak English at an intermediate level. It will help you hone your speaking skills and prepare for the interview. If you think you’re still new to English I recommend taking professional lessons or finding expert language advice online before taking your chance at Toptal.</p>\n<h2>What</h2>\n<p>The english interview is the first phase of the screening process and will assess how well you communicate in speaking English. Toptal calls this the “Language and Personality” test. I’ve witnessed several of this interviews myself and can confidently say the interviewers are very strict with grammatics and your ability to communicate well formed thoughts. It’s not so much about fluency as it is about conveying thoughts in a good way.</p>\n<p>As for the personality test, I haven’t seen candidates being rejected for this reason. Based on the description on their website, though, they say they assess “personality traits and look for candidates who are passionate and fully engaged in their work”. Keep that in mind but remember the most important part of this interview is how well you can communicate in English.</p>\n<p>If you fail this interview you’ll probably be put on hold for 3-6 months, depending on how good or bad you do. Don’t miss your shot and prepare.</p>\n<p>## Why</p>\n<p>Contrary to popular belief, this is somehow the most restrictive filter of them all. According to <a href=\"https://www.toptal.com/top-3-percent\" target=\"_blank\" rel=\"nofollow\">Toptal’s statistics</a> 73.6% of the applicants fail to pass this test. This means they are very rigorous about this process. Think about it: most companies within Toptal are American or European companies. As opposed to say, CrossOver, you’ll probably be part of an native inhouse team, you being the remote outsider. You need to have top communication skills and show yourself as a professional expert. This includes, of course, great verbal and written english.</p>\n<p>Keep this in mind as a way to fuel your motivation. Even when you don’t feel like studying English, think about the number of possibilities that will open up for you if you master this single skill. You’re broadening your work scope from your country and language to pretty much all the world with much stronger currencies.</p>\n<h2>How to prepare</h2>\n<p>Preparing for an interview in english is not only about practicing speaking. It doesn’t either mean to put a few study hours before the interview. You need to be “living” in English: think in English, write your code and commits in English, watch YouTube English-only videos, listen to English-only podcasts, speak with yourself in English. Now, I’m no language expert, but I can tell you I’ve helped a dozen people, including myself, with these techniques. You need to practice all 4 areas of language to become decently fluent: reading, writing, listening and speaking.</p>\n<ul>\n<li>\n<p>Reading: Avoid reading any literature (either online or physical) that’s not written in English. Google everything in English. I recommend subscribing to a collection in Medium or Dev with a topic you’re interested in. Read only the most upvoted as those will normally be written much better. Pick up a non-fiction book on Kindle or your bookstore and read it. Become comfortable reading content in English.</p>\n</li>\n<li>\n<p>Listening: This is critical to your success as a Toptal talent and, in general, as a remote worker for top companies. I recommend watching YouTube videos on TED talks. Put it first with subtitles, and repeat it without subtitles. You should be able to understand 80-90% of what you listen to. Keep doing this, every single day, and you’ll greatly improve your listening. I recommend avoiding practicing with songs: it’s much harder to understand (I was told it was a good idea, I picked Eminem, it didn’t work) and it doesn’t depict a formal environment as a remote work setup</p>\n</li>\n<li>\n<p>Writing: Practice answering any of the sample questions on a piece of paper. See section below.</p>\n</li>\n<li>\n<p>Speaking: Personally, I find self-talking to be the most effective way to practice speaking fluency. You won’t probably improve pronunciation but you will surely get better at your fluency. Read your answers out loud (from writing) to yourself. Do this over and over again. You’ll see how, over the weeks, your brain form neural connections that allow you to think and speak much more fluently.</p>\n</li>\n</ul>\n<h3>Sample questions</h3>\n<p>Write down the answers to the following questions and memorize them. Practice them over and over again. This exercise will serve two important purposes:</p>\n<ol>\n<li>Help you practice your writing and speaking (fluency) skills</li>\n<li>Help you prepare the questions you will probably be asked in the interviews</li>\n</ol>\n<ul>\n<li>Tell me about yourself</li>\n<li>How long have you been programming?</li>\n<li>Why would you like to work as a talent in Toptal?</li>\n<li>What have you heard about Toptal?</li>\n<li>What are the technologies you’re most passionate about?</li>\n<li>Tell me about a time when you made a mistake and how you handled it</li>\n<li>What experience do you have with technology X and Y?</li>\n</ul>\n<h4>Useful resources</h4>\n<ul>\n<li>If you don’t have it already, you need to install <a href=\"https://www.grammarly.com/\" target=\"_blank\" rel=\"nofollow\">Grammarly</a> right now. This will help you catch any grammar mistakes in your writings.</li>\n<li>Use the <a href=\"https://hemingwayapp.com/\" target=\"_blank\" rel=\"nofollow\">Hemingway Editor</a> to double check your writings. It’ll highlight any hard-to-read sentence, wrong uses of words, etc.</li>\n</ul>\n<p>### Speaking</p>\n<ul>\n<li></li>\n</ul>\n<p>Disclaimer: I handpicked and curated what I think are the most relevant apps to practice speaking. Having said that, I haven’t used or tried any of these platforms myself.</p>\n<h3>Daily Prep Bite</h3>\n<p>I recommend the following daily 2-hours practice routine. You can adjust it depending on what your weaknesses are:</p>\n<ul>\n<li>00:00 - 00:30: Listen to english podcasts or watch YouTube videos in English without subtitles</li>\n<li>00:30 - 01:00: Write down a full paragraph answering any of the sample questions. Paste it on Hemingway. Correct it and revisit again.</li>\n<li>1:00 - 1:30: Repeat the answers to your questions out loud. Practice fluency and speak to to yourself.</li>\n<li>1:30 - 2:00: Get yourself a 30 mins session with any of the free online apps I recommend in the previous section</li>\n</ul>\n<p>## Useful resources</p>\n<ul>\n<li><a href=\"https://hemingwayapp.com/\" target=\"_blank\" rel=\"nofollow\">https://hemingwayapp.com/</a></li>\n</ul>\n<h2>Remember</h2>\n<ul>\n<li>It’s ok to have an foreign accent, don’t try to mimic native speakers</li>\n<li>Focus on conveying your ideas as best as you can</li>\n<li>Your interviewers will most probably not be english native speakers</li>\n<li>Put up your best face. <a href=\"https://www.goodreads.com/book/show/35011639-before-you-know-it\" target=\"_blank\" rel=\"nofollow\">Studies suggest</a> humans are inclined to favor friendly, welcoming faces.</li>\n</ul>\n<h1>Online Coding Assessment</h1>\n<p>In this section you’ll learn what the second step of the Toptal interview looks like, what kind of problems you can expect from it and how to prepare. This is not the most difficult part of the interview but you’ll need a lot of preparation to get through.</p>\n<h2>What</h2>\n<p>The coding assessment is an online exam which generally consists of 3 algorithm problems. It’s normally conducted in <a href=\"https://www.codility.com/\" target=\"_blank\" rel=\"nofollow\">Codility</a> where you’ll have 90 minutes to solve 3 problems: easy, medium and hard. This step will filter out <a href=\"https://www.toptal.com/top-3-percent\" target=\"_blank\" rel=\"nofollow\">19% more applicants</a> which will make you on the top 3.6% percentile. This means you’ll be very close to the top 3% if you make it through this filter.</p>\n<h2>Why</h2>\n<p>You may wonder what’s the value in assessing how you solve algorithms when, in fact, you don’t do any of that in your day job. The general conception among high tech companies is that, if you’re smart to solve logical, abstract problems, then you’re smart enough to pick up any language or framework. Whether you love it or hate it, it is what it is and you need to be comfortable with these types of problems. It’s an inconvenience but it’s yet another gate you need to open to get where you want to be. It’s a means to an end.</p>\n<h2>How to prepare</h2>\n<p>The first thing you should know is you’ll need to get an absurd amount of preparation. But not any preparation - you just need the right one. It’s nonsense to train 10 years for the olympics when all you wanted was to win your local competition. You will see a dozen of online services and books that offer coaching to crack the coding interviews at the big 4 (Facebook, Amazon, Microsoft, Google). The thing is, you don’t need such an in-depth preparation to ace the Toptal interview. You need the concepts, but you won’t need to pass a System Design interview or even explain what’s the BigO complexity of your algorithm. I’ve passed interviews at one of the big 4 and it looks so different (not completely) from what Toptal’s coding looks like.</p>\n<p>### Key Concepts</p>\n<p>You should first get familiar with the next 3 concepts.</p>\n<ol>\n<li>BigO Notation: To put it in layman terms, BigO is a standard to tell how efficient your algorithm is. It’ll give an indication on how your algorithm performs in time and space.</li>\n<li>Hashmaps: This is by far the most important concept you should master. I’ve used hashmaps to pass a lot of coding interviews. Their superpower is they can store and fetch data in O(1) time. Think of an object in JavaScript or a Hashtable in Java. I expand on this in the section Hashmaps.</li>\n<li>Strings and lists: This might come off as a basic topic for you but it’s mandatory that you’re fluent manipulating strings and lists. Almost any problem will require you to loop over a list or strings. You don’t want to be looking for syntax specific methods in the middle of an interview. Make sure you can instantly push an element at the beginning of a list, find the length of a string, reverse a list, map and reduce, and so on. Now, don’t just practice the syntax. You need to be able to reason about the BigO time complexity of the algorithms. Interviewers will ask for that. Are you using .reverse? ok, what’s the time cost of doing that?</li>\n</ol>\n<p>### Quick BigO Recap</p>\n<p>BigO is simply a notation that tells you how well or bad your algorithm performs as your input size grows. I’ve used the following tips to solve and analyze algorithms in all my coding interviews.</p>\n<h4>1. O(1)</h4>\n<p>Means your algorithm will take roughly the same amount of time regardless of the input size. Applies normally to math operations and object lookups.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// regardless of a or b, a sum is a math operation that takes just </span>\n<span class=\"token comment\">// one clock cycle to complete</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// no matter of how big your map is (e.g an object in JavaScript), </span>\n<span class=\"token comment\">// a lookup will take 1 cycle to complete</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">lookup</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">map<span class=\"token punctuation\">,</span> key</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> map<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Accessing the <code class=\"language-text\">bar</code> prop from the <code class=\"language-text\">foo</code> object like <code class=\"language-text\">foo.bar</code> is an O(1) operation.</p>\n<p><em>Note: Hashmap lookups are considered to be O(1) in theory regardless of how they solve collisions</em></p>\n<h4>2. O(n)</h4>\n<p>Means your algorithm run time will grow linearly with the input. Take, for instance, the algorithm to find the max number of a list. Your algorithm necessarily needs to visit every element to know which number is the max. If your list grows 2x, your algorithm will roughly take twice the time to complete.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// you need to loop through all the elements to find the max.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">findMax</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">list</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> max <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">Infinity</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>obj <span class=\"token keyword\">of</span> list<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>obj <span class=\"token operator\">></span> max<span class=\"token punctuation\">)</span> max <span class=\"token operator\">=</span> obj\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>3. O(nlogn)</h4>\n<p>This one is easier than what it looks like. Don’t worry about the weird logarithm over there. Logs in BigO notation normally means you’re dividing something into halves, and each half is divided again into halves. But, the only thing you need to remember is this: <strong>O(nlogn) is mostly associated with sorting</strong>. Sorting lists are not free operations, you’re incurring in costs when using them. Let’s see an example of a very inefficient way to get the max of a list:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getMax</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">list</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> b <span class=\"token operator\">-</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>O(n) is better than O(nlogn) because if you multiply 🦄 by logn, you get a bigger 🦄.</p>\n<p>Now you have good criteria to decide what’s most efficient to find a max. Would you use the O(n)? or the O(nlogn) algorithm?</p>\n<h4>4. O(n<sup>2</sup>)</h4>\n<p>Means your input size affects the algorithm like crazy (not quite as bad as others). If your input size doubles, your run time grows 4x. If your input grows 4x, your run time grows 16x. This normally takes the shape of a nested loop. Let’s write a very inefficient way to find if an array has a duplicate.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">hasDuplicates</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">list</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">,</span> el_i<span class=\"token punctuation\">]</span> <span class=\"token keyword\">of</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">,</span> el_j<span class=\"token punctuation\">]</span> <span class=\"token keyword\">of</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!==</span> j <span class=\"token operator\">&amp;&amp;</span> el_i <span class=\"token operator\">===</span> el_j<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>For every element in the list of size n, we’re looping over the whole list of size n. That means we’re visiting the elements n*n = n<sup>2</sup> times.</p>\n<p><em>Can you come up with an O(n) algorithm for this task? one that only loops through the list once? let me know in the comments</em></p>\n<h4>Takeway</h4>\n<p>No need to dig deeper into this topic to ace an easy to medium interview. Just know that some tasks cost more than others and why. Generally speaking, you can go easy with this rule:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">O(1) &lt; O(n) &lt; O(nlogn) &lt; O(n^2)</code></pre></div>\n<h3>Recommended resources</h3>\n<ul>\n<li>\n<p>Cracking the Coding Interview: This is the bible for coding interviews. Now, I’d be irresponsible if I just name the book and not explain to you how to study it. This is my advice:</p>\n<ul>\n<li>Introduction: Read all of it but <strong>put special emphasis on the section for BigO (section VI on my version).</strong></li>\n<li>Data Structures: Read all of it but <strong>put special emphasis on Arrays and Strings</strong>. Safely skip over Stacks and Queues, you won’t need it. You won’t probably need Trees and Graphs either, but I want you to become familiar with recursion and how to think in a <em>recursive way</em>.</li>\n<li>Concepts and Algorithms: Go over the chapters</li>\n</ul>\n</li>\n<li>\n<p>Codility: Definitely …</p>\n</li>\n<li>\n<p>LeetCode</p>\n</li>\n<li>\n<p>Hackerrank</p>\n</li>\n<li>\n<p>InterviewCake</p>\n</li>\n<li>\n<p>BigO: Checkout the <a href=\"https://www.bigocheatsheet.com/\" target=\"_blank\" rel=\"nofollow\">BigO Cheatsheet</a> and <a href=\"https://www.youtube.com/watch?v=v4cd1O4zkGw&#x26;t=11s\" target=\"_blank\" rel=\"nofollow\">this great video</a>.</p>\n</li>\n</ul>\n<h3>How to study</h3>\n<p>From my experience, there’s just one way to study algorithms:</p>\n<ol>\n<li>Take out paper and pen</li>\n<li>Turn off your phone</li>\n<li>Stare at the problem for 30 minutes straight. Don’t look at the solution just yet.</li>\n<li><strong>Important:</strong> Draw a base mock example to warm up your brain. If you need to deal with strings, write an example string. If the algorithm is about matrices, then draw a 3x3 mock matrix.</li>\n<li>Start solving the problem as a human. Don’t think abstract at first (see Introspection section).</li>\n<li>Write down the worst possible solution you can think of. Only pseudocode. No edge cases, no optimization.</li>\n<li>Stop and think. How do you feel about your solution? Do you intuit what you can optimize?</li>\n<li>Optimize. Don’t code just yet. These are my tricks to optimize:\n<ul>\n<li>Do you think you’re doing unnecessary rework? Are you visiting the data points a lot more than what you think?</li>\n<li>Are you missing some piece of information from the problem?</li>\n<li>Important: Can you use an auxiliary data structure, like a hash table, to improve time performance?</li>\n</ul>\n</li>\n<li>Cover edge cases. Online assessments are all about covering edge cases because they will be tested automatically. Are you including negative numbers in your reasoning? empty strings? base cases?</li>\n<li>Code! Don’t write beautiful code. Online tools like Codility or the Toptal interviewers won’t care if your code is beautiful or not. They will only evaluate if your algorithm works and is efficient.</li>\n<li>Record your AHA! moment. I’d say this is the most important step of the preparation. After you finish your algorithm, write down somewhere else your biggest realization. Something like “hashmaps took me from O(n^2) to O(n)” or “I can create a cache variable to avoid revisiting the list”.</li>\n</ol>\n<p>I credit some of this workflow to the book Cracking the Coding Interview.</p>\n<p>### Introspection</p>\n<p>Let’s say you need to find the highest pair of numbers in a list. How do you solve this as a human? Your brain doesn’t store anything in variables or even sort the list. Your brain sees the numbers and instantly knows what are the top two numbers. But, is it really instant, though?</p>\n<p>Take a step back and think about it. How did you know the first number was not the highest? because you knew you had to see all the numbers before taking a decision. This means there’s no better way to do it other than looping through all the numbers (in other words, it’s O(n) at best). Now, you know there are bigger numbers than the one you’re looking at. How? because your brain saw it and kept a reference as the biggest number. This could be translated into “storing the biggest in a variable”. You can find the highest number, what about the second highest? What my brain did was to start all over again but ignoring the previous number. Great! we have a working algorithm now: we’ll visit each number and keep reference of the highest. We remove that one from the list and loop again to find the next highest.</p>\n<p>Is that the best you can do? definitely not but, at least, it’s a working solution. It got you unblocked. It got your neurons up and working - they’re warmed now to optimize.</p>\n<h3>Some remarks</h3>\n<ul>\n<li>BigO: You need to master O(logN) or O(2^n). I recommend you to master the basics. Learn to identify O(1), O(n) and O(n^2) algorithms. Make so many exercises that these concepts just slip out of your brain with no effort.</li>\n</ul>\n<h3>Sample exercises</h3>\n<p>Important: There’s no value on reading the question and going straight to the answer. You’ll lose your time. Put a lot of effort and try to solve the problem yourself. Try to come up, at least, with the worst possible and most inefficient algorithm. Bonus points if you manage to get the best solution.</p>\n<ol>\n<li>\n<p><strong>Poker Chips:</strong> Luigy works in a Casino and he gives customers poker chips in exchange of money. Find the minimum number of chips Luigy can use to match the customer requests. He has chips worth 100, 50, 25, 10, 5, 1. For example, for 126 Luigy should give 3 chips (100, 25, 1).</p>\n</li>\n<li>\n<p><strong>The wedding:</strong> Lina and Carlos are getting married. They both have an invitee list. Find out if they both want to invite the exact same people.</p>\n</li>\n<li>\n<p><strong>Duplicate characters:</strong> Find the top most repeated character in a string. For instance, given a string ‘hello world’, the top most repeated character is ‘l’ because it can be found 3 times in the string.</p>\n</li>\n<li>\n<p><strong>Balanced Brackets:</strong> Given a mathematical operation. Find out if the brackets are placed such that the equation is valid. There are 3 types of brackets: (,[,{.</p>\n</li>\n</ol>\n<h3>Solutions</h3>\n<h4>1. Poker Chips</h4>\n<p>This is a problem you are likely solving on a daily basis when handling money. If someone is paying you and you need to give change, you normally optimize and don’t give all your coins. You probably find your biggest coins and see how many of them would sum up to a close number. Then you find your next biggest coins and add them to the previous coins so that they won’t surpass the total change. It’s almost unconscious, but this tells you something about how to solve this problem.</p>\n<p>Let’s then follow that rationale to solve this problem:</p>\n<ol>\n<li>\n<p>Say you want to add chips up to 273 USD. What you would do in a normal scenario is first to find the biggest coin you have because, otherwise, you’d end up using more coins than necessary. Now, how do you find how many of those coins you can max use? Let’s divide 273USD over 100USD to find out. This is 2.73 which means you can use 2 chips of 100USD and you’d be left with 73USD to fill.</p>\n</li>\n<li>\n<p>So, what now? you start the problem again trying to fill 73USD but this time without the 100USD chip. You use the second best of your options which is the 50USD chip. 73USD/50USD yields to 1.46 which means you can only use 1 coin of 50USD. How much do we have left? it’s not 46USD. It’s just the same 73USD minus 1 chip of 50USD which means we’re left with 23USD now.</p>\n</li>\n<li>\n<p>The next big coin is 25USD. Divide 23USD into 25USD and you get 0.92. This means you can’t even use a 25USD coin. It’s straightforward as 25 > 23 and you don’t want to give away your money.</p>\n</li>\n<li>\n<p>Let’s try 10USD now. 23USD/10USD = 2.3. Use 2 coins of 10USD and you’re left with 23 - 2*10 = 3USD.</p>\n</li>\n<li>\n<p>Your last coin is 1USD. 3USD/1USD = 3 coins.</p>\n</li>\n</ol>\n<p>The answer for this problem would then be 8 (for chips 100, 100, 50, 10, 10, 1, 1, 1).</p>\n<h5>Implementation</h5>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getNumChips</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">val</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> chips <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">25</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">let</span> numChips <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>chip <span class=\"token keyword\">of</span> chips<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> num <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>val <span class=\"token operator\">/</span> chip<span class=\"token punctuation\">)</span>\n    val <span class=\"token operator\">-=</span> chip <span class=\"token operator\">*</span> num\n    numChips <span class=\"token operator\">+=</span> num\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> numChips\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>##### Edge cases</p>\n<p>After you have a working solution, think about some edge cases. This will help you polish the algorithm. We’ll go through some of them, implementing them in code is left as an exercise for the reader.</p>\n<ul>\n<li>Negative values: ask your interviewer what you should do in this case as it totally depends on the spec. I’d go with an exception, as returning 0 is not quite accurate - not even with 0 coins you can fulfill a negative number.</li>\n<li>Decimals: ask your interviewer if the input range is only integers or if doubles are allowed too. You might want to round the number before going into the loop.</li>\n</ul>\n<h5>BigOn Analysis</h5>\n<p>Think about this. For 273USD you solved the problem in 5 steps. Each one involved a mathematical operation. Mathematical operations are O(1) in time, it can be computed immediately by the machine. Now, how many steps would you need if the amount was 60.520 USD? You would divide by 100, find the max number of 100USD chips and then continue with 50USD. You see where this is going, it’s the same 5 steps, the same 5 computations. If small and large numbers need just 5 calculations to solve the problem, this means we have constant time of O(5). Now, as per the theory, for any k > 1, O(k*1) = O(1). With k=5 we have O(5) which means <strong>our algorithm is O(1) in time</strong>.</p>\n<p>You might think, how come this is O(1) when you have a for cycle? Don’t be confused about that. Space complexity only tells how the algorithm performs depending on the size of the input. We showed that it’s the same for small and large inputs. Also, see that the loop is always constant over 5 elements. We could have easily do this without the loop, just did it for convenience.</p>\n<h5>AHA moment</h5>\n<p>You were asked to minimize the number of chips to fill a total amount but you end up maximizing the USD per chip in each step. This is your AHA moment: <strong>minimizing globally means maximizing locally</strong>. This is not true all the time but it’s definitely a trick that can get you unblocked.</p>\n<h4>2. The wedding</h4>\n<p>This might seem like an easy problem at first. Verifying if two lists are equal is something you might have done a few hundreds times before. But, are you doing it optimally?</p>\n<p>Let’s see how your brain does this naturally. Take the first element from list 1 and find it in list 2. Now take the second element from list 1 and find it in list 2. Every time you find a matching pair, put a stroke over them. If you find an item that exists in list 1 but not in list 2, then you know they are not identical. If all the items in list 1 exist in list 2, but there are unstroked items in list 2, then both lists are not identical. If all items in list 1 are found in list 2 and there’s no item unmarked, then you can say both lists are identical.</p>\n<p>We got it! We have a working algorithm, that’s the first step. Do a first introspection to recognize how your brain works. Now, is that the best we could do? Let’s get more technical and analyze the time complexity. For every item in list 1 we’re looping in list 2 to find a matching pair. Be careful, this doesn’t mean our algorithm is O(n^2). Indeed we have nested loops but, what does ‘n’ represent? both lists can grow indistinguishable. If n and m are the sizes of list 1 and 2, correspondingly, then our algorithm is O(n*m) in time.</p>\n<h5>Optimization 1: Avoid rework</h5>\n<p>Let’s optimize a little bit. We’re doing a lot of rework because we shouldn’t visit the items in list 2 that have been found already. What if you skip them? You would then visit less elements each time you find a matching pair. Take an item from list 1, find it in list 2. Next time you won’t look over m elements but instead over m - 1. Then, after that, you’ll loop over m - 2, and so on. This means that the number of times you visit the elements in list 2 is m + (m-1) + (m-2) + … + 1. This is known as a telescopic sum and can be expressed as m * (m + 1) / 2. If you open the parenthesis, this is (m^2 + m)/2. This means we’re still dealing with quadratic times. In BigO notation you can ignore the least dominant term so our optimized algorithm is O(n^2). Now, is this really the best we can do? Do you not feel like we’re still doing rework by looping the list again and again on every iteration?</p>\n<h5>Optimization 2: Sort</h5>\n<p>Now, we could also think about sorting both lists. If you sorted list 1 and list 2 then you could verify that all the values in the same indices are identical. Take an index ‘i’ from 0 to list 1 length and verify that list1[i] == list2[i]. Is this better than the previous alternative? Let’s see. Sorting list 1 is O(nlogn) and sorting list 2 is O(mlogm). Then finally you loop over all the items one last time. This means the final complexity in time is O(nlogn + mlogm + n). ‘n’ is the least dominant term here so we can ignore it (why? because n multiplied by a non-constant term like logn is always greater than simply n). This means our algorithm is O(nlogn + mlogm). We went from n^2 to nlogn which means that, in fact, we did much better with this approach. But, do you not feel sorting is a bit overkill for such a simple task? let’s see if we can do better.</p>\n<h5>Optimization 3: Enter hashmaps</h5>\n<p>Let’s try what I call “the copper bullet”. It’s not a silver bullet as it won’t work for every problem but it’s definitely useful for a big chunk of them. Enter <strong>hashmaps</strong>. As reviewed in previous sections, a hashmap is a data structure that lets you write and read in O(1) time. Let’s see how to leverage this fact to improve our algorithm:</p>\n<ol>\n<li>\n<p>Loop over all elements of list 1. Store each element in a hashmap.</p>\n<ul>\n<li>The key will be the invitee name and the value will be 1.</li>\n<li>If a name already exists then increase the number by one.</li>\n</ul>\n</li>\n<li>\n<p>Loop over all elements of list 2. Treat each element as the key of the hashmap and try to find its value.</p>\n<ul>\n<li>If a value is found, then decrease the value by 1.</li>\n<li>If no value is found, it means it wasn’t put on the map, so both lists are not equal.</li>\n</ul>\n</li>\n<li>\n<p>Loop over the values in the hashmap.</p>\n<ul>\n<li>If some value is different than zero, it means one list has a value that appears more or less times than in the other list. This yields to both lists not being identical.</li>\n<li>If all values are zero, it means both lists are identical</li>\n</ul>\n</li>\n</ol>\n<p>Let’s put all this into code and see how our algorithm looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">verifyAllEqual</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">list1<span class=\"token punctuation\">,</span> list2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// fail fast if both lists are not the same length</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>list1<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> list2<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">let</span> map <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// loop through list 1, fill the hashmap, count characters</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>num <span class=\"token keyword\">of</span> list1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      map<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      map<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// loop through list 2, decrease character count on hashmap</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>num <span class=\"token keyword\">of</span> list2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    map<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span><span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// if any count is greater than 0, both lists are not identical, abort</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>val <span class=\"token keyword\">in</span> map<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">[</span>val<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>##### Edge cases</p>\n<p>After you have a working solution, think about some edge cases. This will help you polish the algorithm. We’ll go through some of them, implementing them in code is left as an exercise for the reader.</p>\n<ul>\n<li>How well does your algorithm handle empty lists? what if both lists are empty?</li>\n<li>What if one of the lists is much bigger than the other? would you find it better to start looping over the short one? or the large one?</li>\n</ul>\n<h5>BigO Analysis</h5>\n<p>We did BigO time complexity analysis for all the previous algorithms. We’ll focus now on the last optimization. We first loop over all elements of list 1 and visit each element just once. This is O(n). When we finish that, we go over list 1 and do the same, this is O(m). Finally, we loop over the values in the hashmap which, in the worst case scenario with no duplicates, has n elements (i.e all values from list 1 stored in the map). This yields to another O(n). The time complexity is then O(n + m + n) => O(2n + m) => O(n + m). Now, notice that the second loop terminates quickly when no matching element is found in list 1. This means that, at most, you only loop through n elements in the second list, even when its length is ‘m’. This would finally yield a time complexity of O(n + n) => O(2n). In BigO notation we only deal with the shape of the curve (constant, linear, quadratic, etc) so O(k * n) => O(n). Our algorithm is <strong>O(n)</strong> in time.</p>\n<p>How do you know this is the best you can do? To know that both lists are equal you should, at least, know what are the elements in the list. How do you know them? by visiting them. This means you should, at least, visit every element which is exactly O(n). You can’t do better than that, because you can’t leave any element unvisited.</p>\n<h5>AHA moment</h5>\n<p>We realized we were doing rework as we were visiting each element a lot of times. But, what really took us to the next level, was the <strong>hashmap</strong>. Hashmaps are really the copper bullet for most algorithms as the hashing power let you write and read in O(1).</p>\n<h4>3. Duplicate characters</h4>\n<p>Almost anyone can solve this problem in their mind for short sentences. Let’s see how our brain works, no algorithms involved. You start skimming through the words and get a feel of which characters are candidates for repetition. How do you know that? because your short memory helps you with retention until something becomes more and more familiar. But, still though, you can’t easily tell if a character has been repeated 5 or 6 times, until you count them. You need to keep a record of what characters are repeated and how many times.</p>\n<p>Following the rationale above, we can outline a rough working algorithm:</p>\n<ul>\n<li>For every character, visit the rest of the string and count how the number of times it’s repeated.</li>\n<li>Keep track of the characters and the number of visits</li>\n<li>Finish the algorithm by finding the max of the counts</li>\n</ul>\n<p>For the last exercise, you already know you can use maps to store key-value pairs. We can then leverage this data structure to keep out character count. Let’s see how this looks like in pseudo-code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">counter = map()\n\n# build counter\nfor i = 0 and i &lt; input.size # for every character...\n  char_i = input[i]\n  if !counter.has(char_i) # ...if we haven't seen this character before...\n    for j = i + 1 and j &lt; input.size # ...visit the rest of the string...\n      char_j = input[j]\n      if char_i == char_j: # ...coincidence found? update counter...\n        counter.char_i++\n\n# find max\ntop_repeated = ''\nfor char in counter:\n  if counter.get(char) > counter.get(top_repeated):\n    top_repeated = char\n\nreturn top_repeated</code></pre></div>\n<h5>Optimization 1: Avoid rework</h5>\n<p>Our first would work just fine. Let’s see how expensive it is. For every character, we loop through every other character. This means our first run will visit N elements. The next iteration will visit N-1. Next one will be N-2. You get it. Hence, the number of steps our algorithm needs to terminate is: N + (N-1) + (N-2) + … + 1. As shown in problem #2, this behaviour means our algorithm runs in quadratic time: O(n^2).</p>\n<p>Can we do better? Do you not feel like we’re doing some rework over here? We’re running an inner loop to count coincidences, is that necessary? Can’t we just keep a counter map with the number of coincidences of each character? Think about it for a second. Your brain is implicitly keeping a map with the number of times it sees a letter. Can’t we just do the same? We’re effectively changing the problem from “find the most repeated char” to “count the number of occurrences for each char”.</p>\n<p>Let’s see how our final algorithm looks like. Code snippet is shown in JavaScript.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">findTopRepeated</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">sentence</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Build counter map</span>\n  <span class=\"token keyword\">const</span> counterMap <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> char <span class=\"token keyword\">of</span> sentence<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>counterMap<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      counterMap<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      counterMap<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// Find max</span>\n  <span class=\"token keyword\">let</span> top <span class=\"token operator\">=</span> <span class=\"token string\">''</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> char <span class=\"token keyword\">in</span> counterMap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>counterMap<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> counterMap<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> counterMap<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      top <span class=\"token operator\">=</span> char\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> top\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h5>Optimization 2: Merging loops</h5>\n<p>At this point you have the most performant solution in terms of BigO behaviour (we discuss this in depth later). Now, is it really necessary to run two separate loops? can we keep track of the top most repeated char while we count the coincidences? Yes, it makes no difference. You’ll end up counting them all anyways. Let’s see what it looks like now.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">findTopRepeated</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">sentence</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Build counter map and keep a running max</span>\n  <span class=\"token keyword\">const</span> counterMap <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">let</span> top <span class=\"token operator\">=</span> <span class=\"token string\">''</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> char <span class=\"token keyword\">of</span> sentence<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>counterMap<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      counterMap<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      counterMap<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>counterMap<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> counterMap<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> counterMap<span class=\"token punctuation\">[</span>top<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      top <span class=\"token operator\">=</span> char\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> top\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now, this one feels much better. We went from 2 loops to just 1 in no time, it’s almost free profit.</p>\n<p>##### Edge cases</p>\n<p>This is an exercise for you. Think about what edge cases you can encounter and solve them. What happens if there’s no character repeated? The problem didn’t say anything about it, it’s up to you how to solve it. What happens with blank spaces? will that count as a character? if not, then deal with it, make sure you don’t count empty characters. You can even clean the sentence before the algorithm, it’ll make it run faster.</p>\n<h5>BigO Analysis</h5>\n<p>Just by looking at the code, we can tell we’re no longer in the quadratic realm because we got rid of the nested loops. We’re looping through the sentence just once, char by char. At first we had 2 loops which, in the worst case scenario (no char repeated), would end up being O(2n). As per BigO properties, O(k*n) is equivalent to O(n) so we have linear time. Please remember BigO is a mere measure of how your algorithm performs relative to how the input grows. It doesn’t imply anything about the absolute run time. If O(n) takes 100ms, O(2n) will take 200ms. This is irrelevant for performance analysis, though. After our second optimization we got rid of the second loop and got an effective, O(n) linear time.</p>\n<p>To find the space complexity we need to think about the data structures we introduced to solve the problem. In this case, we’re saving a counter map which, in the worst case, would keep a copy of all the characters in the input string. Does this mean we have O(n) space complexity? Not so fast. The maximum size of our map is the number of characters in the alphabet. Let’s say it’s 27. Therefore our map will have no more than 27 key-value pairs. The space complexity is then O(27), which is effectively equivalent to O(1).</p>\n<h5>AHA moment</h5>\n<p>You might think the AHA moment for this problem was using the hashmap, same as problem #2. But, it was actually when we switched the problem and paraphrased it in a different way; that’s when we found the most performant solution. We stopped thinking about “finding the top most repeated” and started thinking about “logging the number of occurrences per character”. Then we got ourselves in front of a well known problem: finding the max number in a list.</p>\n<p>Remember this: Always try to boil problems down to subproblems that you already know how to solve. In the future, you might find problems that require you to find repeated elements in lists. You already know it can be done in O(n) with hashmaps. That’s going to be familiar and will put you one step ahead.</p>\n<h4>4. Balanced Brackets</h4>\n<p>Let’s first draw two basic problems to get us warmed up.</p>\n<ul>\n<li><strong>Balanced:</strong> <code class=\"language-text\">(4+[1-(-2)])</code></li>\n<li><strong>Unbalanced:</strong> <code class=\"language-text\">[{(5+2)]</code></li>\n</ul>\n<p>We’ll put names to the brackets just for convenience. () is type P, [] is type Q, and {} is type R.</p>\n<p>Right. Let’s now try to solve the problem in our brains. Our eyes ignore all the opening brackets and focus only on the closing ones. I get to the first closing bracket of type P and think “ok, this one should close the last open bracket I saw”. I keep moving and see another closing bracket, this time of type Q. “right, this one should close the last open bracket I saw, and that last bracket should be of type Q”. <strong>I also tend to skip those inner brackets that have already been closed,</strong> because they are already resolved anyways.</p>\n<p>Let’s try to implement this same algorithm in pseudocode. Notice we’re somehow keeping a list in our memory. This means we need to add the brackets to a list. Also, notice we tend to skip the inner brackets that have been resolved. How do we translate this to code? well, “skipping it” means ignoring it, so we don’t really need the open brackets that have been resolved; we’ll remove resolved brackets.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">brackets = []\nfor every c in equation\n  if c is an open bracket\n    brackets.add(c)\n  if c is a closed bracket\n    if type of c == type of last(brackets)\n      brackets.remove_last()</code></pre></div>\n<p>For the equation to be valid, all brackets should have been resolved. Also, as you saw, we’re removing resolved brackets from the list. This means that, for all the brackets to be balanced, we should expect our <strong>list to have length 0 at the end of the algorithm</strong>. Otherwise, there was a bracket that didn’t get closed. This is a great start. It won’t cover all the edge cases (like an equation with only closing brackets), but it’ll be fine for a first iteration.</p>\n<p>Can we find out something more optimal? think about BigO time complexity for a minute. Our algorithm is looping through all the characters once. This means our algorithm is O(n). For someone to tell if an equation is valid or not, they need to look at the whole equation. No character should be skipped. This means there’s nothing better than “looking at every character”. Therefore, we can be confident there’s no better way to do this than O(n).</p>\n<h5>Enter Stacks</h5>\n<p>This is a classic example to get you started with Stacks. A Stack is a FILO (first in, last out) data structure which lets you push and pop elements in O(1). The elements are pushed at the end of the list and are also popped from the end of the list. Think like a stack of poker chips. Remember we were pushing and removing brackets from the end of a list? Well, it seems like we can make it cleaner with a Stack.</p>\n<p>Let’s assume we have a data structure called <code class=\"language-text\">Stack</code> with methods <code class=\"language-text\">push</code> and <code class=\"language-text\">pop</code> which will add and remove from the list tail, correspondingly. We’ll also have a <code class=\"language-text\">last</code> method which will give us the last element without removing it from the list. Assume we have aux function like <code class=\"language-text\">isOpeningBracket</code> and <code class=\"language-text\">isClosingBracket</code> which will validate if a character is opening or closing, correspondingly. Finally, we’ll need a function <code class=\"language-text\">isValidPair</code> which takes two characters and validates if they are any of <code class=\"language-text\">()</code>, <code class=\"language-text\">{}</code> or <code class=\"language-text\">[]</code>. This is how our algorithm would look like in real code.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">validateBrackets</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">equation</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> stack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Stack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>letter <span class=\"token keyword\">of</span> equation<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isOpeningBracket</span><span class=\"token punctuation\">(</span>letter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>letter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isClosingBracket</span><span class=\"token punctuation\">(</span>letter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isValidPair</span><span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">last</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> letter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> stack<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Note: JavaScript has <code class=\"language-text\">push</code> and <code class=\"language-text\">pop</code> methods in vanilla Arrays so we don’t really need to implement the Stack data structure. This is just for explanation purposes.</p>\n<h5>Edge cases</h5>\n<p>After you write your first algorithm, make sure to come up with contrived examples with weird edge cases. Let’s look at this one, for instance: <code class=\"language-text\">]]]]]]</code>. How would our algorithm behave for such an unbalanced expression? There’s no opening bracket so our stack will always be empty. Every time the loop lands on a closing bracket it will check if it’s a valid pair with the last stack element, which is null. This will, of course, be false and therefore we pass on to the next iteration. At the end of the algorithm out stack length is indeed 0, so our algorithm will classify this as <code class=\"language-text\">true</code>.</p>\n<p>Let’s fix this. Check this out: Every closing bracket is a decisive point in our algorithm. If it doesn’t pass our test then we should terminate and return false right away. You got it? There’s no point in looping any further if one closing bracket didn’t match is opening counterpart. With this in mind, let’s modify our algorithm to <em>fail early</em> when a valid pair is not found.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">validateBrackets</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">equation</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> stack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Stack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>c <span class=\"token keyword\">of</span> equation<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isOpeningBracket</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isClosingBracket</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">isValidPair</span><span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> stack<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Notice how we don’t need <code class=\"language-text\">last</code> anymore. We <code class=\"language-text\">pop</code> right away. If it’s a valid bracket, we were going to remove it from the stack anyway; if it’s not valid, we terminate the algorithm.</p>\n<h5>BigO Analysis</h5>\n<p>As analyzed earlier, our algorithm is O(n) in time because it visits each element exactly once. We also showed there’s no better and more performant way to solve this problem. What’s the space complexity? Worst case scenario is we find an equation with only opening brackets. This means we’d end up with a stack of n elements. Our algorithm is then O(n) in space.</p>\n<h5>AHA moment</h5>\n<p>The aha moment is realizing we don’t need resolved pairs in the equation anymore. When we don’t need anything, we’re effectively removing it. When you see yourself ignoring something in your brain, that probably means removing it all over. In our case, it all led to us using a Stack and popping elements all over.</p>\n<h1>Test Project</h1>\n<p>The general belief is that, when you get to this point, you’re pretty much a Toptaler already. I’ve heard this should be a straightforward step for someone who just went through the full application and cleared all the filters. I, personally, don’t think this is the case.</p>\n<p>The advantage, though, is that you have plenty of time to work on this by yourself. The drawback is you may not know it all and you’ll need to research a lot. But that’s fun too. Let’s see what to expect and how to prepare for this step.</p>\n<h2>What</h2>\n<p>This is the last step of the process. It consists of 2 parts. First, they will send you a project spec and you will have 2 weeks to build it as if it was for a client. Second, you’ll interview real time with a toptaler to showcase your project and support all your decisions. They will ask you all kinds of questions ranging from fundamentals to project-specific stuff.</p>\n<p>This step is supposed to filter out <a href=\"https://www.toptal.com/top-3-percent\" target=\"_blank\" rel=\"nofollow\">0.2% more candidates</a>. This means 32 out of 1000 people get to this point, and 30 of them will pass. Now, I need to make emphasis on this: do not underestimate this phase. I myself have referred overconfident people who play hard to get to this point only to see them fail. Make sure you deliver world class work here.</p>\n<h2>Why</h2>\n<p>This can easily be the most important, critical part of the process. This is where you show off all your experience and your true engineering skills. Solving a real world problem is the only way you have to demonstrate you can write good code. You’ll be pushed to think about all aspects of an app in a clean, maintainable, and scalable way. It’s ultimately very similar to what you’ll be doing on a daily basis.</p>\n<p>## How to prepare</p>\n<p>It can be daunting at first to tackle a problem of this magnitude. You will probably feel unqualified from the very get go. You might be good at frontend development but not feel confident about building an API. Or, you might be strong on the backend but lack UI/UX skills to make something look decent. This is normal, you can’t excel at everything.</p>\n<p>The key here is to know what to study and where to focus. In the next few sections, I’ll point out the main key concepts you should study in order to deliver a great project. We’ll start reviewing a sample project and we’ll go piece by piece discussing what’s expected from you and what you should learn.</p>\n<h3>Sample Exercise</h3>\n<p>I’ll focus here on what you’ll probably be applying for: web development. The project you’ll have to build is probably either a full-stack or a frontend only project. It depends on whether you use a backend-as-a-service to build your API (ie Firebase), or create your own backend using your preferred language. You’ll probably be given a very vague definition of a problem and this will be on purpose: they want to test how well you adapt to uncertainty.</p>\n<p>Let’s see what a problem statement looks like:</p>\n<p>You should build an application to rate books:</p>\n<ul>\n<li>Users can add and remove books on their account</li>\n<li>New users must sign up with email and password. Email confirmation is not mandatory.</li>\n<li>Existing users log in via email and password</li>\n<li>Every book consists of a name, author and a numeric rating (from 1 to 5)</li>\n<li>Users can update the rating of a book on their account</li>\n<li>Users can filter their books by rating</li>\n<li>Create an admin role whose dashboard shows all the books from all users</li>\n<li>Admins can only view ratings but not edit them</li>\n<li>Admins can filter books by created date</li>\n<li>Clean and good looking UI/UX is expected</li>\n<li>The API must be Restful. All actions should be executed via API.</li>\n<li>Optional. Use a backend-as-a-service, like Firebase, if you don’t know how to implement a backend. In any case, your interviewer will probably assess your knowledge in APIs and make you test it via Postman or cURL.</li>\n</ul>\n<p>You must deliver a fully functional app as if it was for a client. You’ll probably be given a Gitlab repo with access to push your code. They won’t review your commit messages but I recommend to be professional with that. It’s the little details that count.</p>\n<p>We’ll go over what you should focus on both the frontend and the backend.</p>\n<h3>Frontend</h3>\n<ul>\n<li>It’s expected that you build a SPA (Single Page Application) so you’ll need to rely on some framework like Angular, React, or Vue.</li>\n<li>Make sure to use a battle-tested, proven UI library like Material components. All the major frameworks have a library for this: Angular Material, Material-UI (React) and Vue Material.</li>\n<li>Use a common CSS framework. This is not the time to build your own framework. Just use whatever works like Bootstrap or Tailwind.</li>\n<li>Implement good routing. I recommend every page in your app to have an individual reachable URL, even login and signup.</li>\n<li>Write authentication guards. They should automatically route your users to login/signup when accessing forbidden routes. Make sure you understand this concept and talk about it in the interview.</li>\n<li>Built E2E tests. At least 2 or 3, they are not normally mandatory but will show you think about maintainable code. I hugely recommend doing this with Cypress. It’s the fastest and easiest way to write E2E tests.</li>\n<li>Implement network interceptors to add your auth tokens in a clean way. You can achieve this with HTTP interceptors (Angular), Axios interceptors (React) for <code class=\"language-text\">VueResource</code> (Vue).</li>\n<li>Make sure your app is responsive. This will tell your interviewer you think mobile first, which is critical in the web scene today.</li>\n<li>Test in at least 3 major browsers. Leveraging a UI component library and a CSS framework is a great way to mitigate risks with this. I recommend testing in Chrome, Firefox and either Safari or Edge, depending on your OS.</li>\n<li>Go modular. Make sure you build independent components with very clear inputs and outputs. If your component is growing too large, consider dividing it into smaller components. This is critical because your interviewer will ask you to add features in the live screening. If you have spaghetti code all over the codebase, you’ll find it very hard to do this fast.</li>\n<li>Good folder architecture. Make sure you show a clean codebase with well defined folders: models, utils, shared, components, assets.</li>\n<li>Use TypeScript. It’s first-class in Angular but, if you work on React or Vue, I highly recommend using the TypeScript starter. This will make your code look much cleaner. You can also tell your interviewer this makes it more maintainable in the long term.</li>\n<li>Styling. Avoid inline styles in your HTML <code class=\"language-text\">&lt;div style=\"color: red\"></code>. Style classes only <code class=\"language-text\">.my-class { color: blue }</code>, not HTML tags directly. If using CSS-in-JS, use semantic names for your styles.</li>\n<li>Always aim to do sorting and filtering on the backend. Doing this in the frontend will probably tell your interviewer you don’t think enough about scalability.</li>\n</ul>\n<h3>Backend</h3>\n<ul>\n<li>Use your favorite framework and programming language to build the API. I recommend sticking to the known ones: Python, Java, NodeJS, PHP, .NET, Go.</li>\n<li>No matter what you do, always go Restful. Research about how a truly Restful API should look like. Avoid having routes like <code class=\"language-text\">POST /api/add-book</code> or <code class=\"language-text\">GET /api/filter-by-rating?rating</code>.</li>\n<li>Make sure you understand the difference between URL parameters (<code class=\"language-text\">/users/:id</code>) and query strings (<code class=\"language-text\">/users?sortBy=:order</code>) and when to use them.</li>\n<li>Handle authentication properly. Do not store plain text passwords. Look for ‘salt hashing’, learn to manage secrets in the server. Study this over and over again until you understand how clean auth works.</li>\n<li>Handle authorization properly. Look online how to best organize roles in a database with an authorization scheme.</li>\n<li>Choose your DB properly. You’ll have to support your decision in the interview. Whether you go with SQL or NoSQL, make sure you read the differences beforehand and be ready to answer questions like “why MySQL and not Postgres? why is this app better for a NoSQL?”</li>\n<li>Write unit tests. If working on NodeJS there are several resources online on how to test your Mongoose controllers with Mocha and Sinon. If working with Python/Django, there’s a complete section on Testing in their docs. Remember: just do a few tests, don’t spend too much here. You can say you focused on the critical components and you moved on. This will at least show you care about testing; it’s critical in picturing you as an expert.</li>\n<li>ORM. It’s highly advised to leverage an ORM like Mongoose objects or Django models to manage DB objects. I wouldn’t recommend having plain SQL statements on your codebase, at least for this project. You won’t probably be asked to show off your SQL skills so having them can be detrimental.</li>\n<li>Dev vs Prod settings. You won’t be asked to deploy your project, don’t spend time on it. However, make sure you understand what configs can be made public and which ones should be secrets. This typically involves DB passwords, API Keys, or any other credentials. This data should not be committed to your repo and should instead be kept secret in the prod server. Again, you don’t have to do any of this, but it’s critical to understand this concept.</li>\n<li>Learn to use Postman. You’ll be asked to open this, or cURL, in your interview. Be prepared to create a POST request with authorization headers, to create a JSON payload, or to analyze the headers of a GET request.</li>\n<li>Use middlewares. When you use middlewares you show you understand the different layers of an app in the backend. You can use middlewares to verify authentication or authorization, manage sessions, append headers, write logs, cookie management, etc.</li>\n<li>Headers. Using advanced headers will make you look ahead of the curve. Believe or not, most devs won’t ever go into configuring security headers as they trust their framework so much. I’d stick with headers like CSP and disabling X-powered-by. Make sure to talk about this in your interview.</li>\n</ul>\n<h3>Tips for the interview</h3>\n<p>You can’t just build a great project and go unprepared to the call. I recommend these specific steps to prepare your screening:</p>\n<ol>\n<li>Make sure you can run the project right after the first git clone.</li>\n<li>They will probably ask you to use the existing project on your local, so have it up and running for the call.</li>\n<li>Get Postman (or your favorite HTTP client) ready for the interview.</li>\n<li>Be confident but also authentic. If you don’t know a concept just say you know something about it, mention what you know, but be willing to say “I don’t know at this time, I would just search for that”.</li>\n<li>Practice some dummy questions before the interview: add a new role, add a new object to the DB, add a new data filter, add a new dialog on the frontend, etc.</li>\n<li>Always think you’re presenting to a customer. Don’t take it as yet another interview but as a demo to a real client.</li>\n</ol>","frontmatter":{"title":"Cracking the Toptal Interview - Draft","description":"Draft v1.8","meta":null,"date":"April 20, 2020"}}},"pageContext":{"slug":"/ctti-draft/","previous":{"fields":{"slug":"/quarantine/quarantine-day-31/"},"frontmatter":{"title":"Quarantine — Day 31"}},"next":{"fields":{"slug":"/tracking-instagram-followers-like-a-true-nerd/"},"frontmatter":{"title":"Tracking Instagram followers like a true nerd"}}}},"staticQueryHashes":["3649515864","63159454"]}